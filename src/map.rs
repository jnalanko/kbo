// sablast: Spectral Burrows-Wheeler transform accelerated local alignment search
//
// Copyright 2024 Tommi MÃ¤klin [tommi@maklin.fi].

// Copyrights in this project are retained by contributors. No copyright assignment
// is required to contribute to this project.

// Except as otherwise noted (below and/or in individual files), this
// project is licensed under the Apache License, Version 2.0
// <LICENSE-APACHE> or <http://www.apache.org/licenses/LICENSE-2.0> or
// the MIT license, <LICENSE-MIT> or <http://opensource.org/licenses/MIT>,
// at your option.
//
/// Evaluates the CDF of _k_-bounded matching statistics random match distribution.
///
/// Computes the log-probability that a matching statistic with value
/// `t` or less that is the result of mapping a _k_-mer with
/// `alphabet_size` possible characters against an index containing
/// `n_kmers` _k_-mers was generated by chance.
///
/// # Examples
/// TODO Add examples to log_rm_max_cdf
///
/// # Distribution of random matches in _k_-bounded matching statistics
/// TODO Add the maths
///
/// Credit to Jarno N. Alanko for deriving the random match distribution.
///
pub fn log_rm_max_cdf(
    t: usize,
    alphabet_size: usize,
    n_kmers: usize,
) -> f64 {
    assert!(n_kmers > 0);
    assert!(alphabet_size > 0);

    n_kmers as f64 * (- ((1.0_f64.ln() - (alphabet_size as f64).ln()).exp()).powi(t as i32 + 1)).ln_1p()
}

/// Determines a lower bound for non-random _k_-bounded matching statistic values.
///
/// Computes the probabilities that the possible values for the
/// _k_-bounded matching statistics (MS) of a _k_-mer with size `k`
/// mapped against an index with `n_kmers` total _k_-mers and
/// `alphabet_size` possible values at each character are random
/// matches. Computation terminates when the MS value that produces a
/// random match probability below `max_error_prob` is found and
/// returned.
///
/// If no MS value passes the check, the function returns `k` instead.
///
/// # Examples
/// TODO Add examples to random_match_threshold documentation
///
pub fn random_match_threshold(
    k: usize,
    n_kmers: usize,
    alphabet_size: usize,
    max_error_prob: f64,
) -> usize {
    assert!(k > 0);
    assert!(n_kmers > 0);
    assert!(alphabet_size > 0);
    assert!(max_error_prob <= 1 as f64);
    assert!(max_error_prob > 0 as f64);

    for i in 1..k {
	if log_rm_max_cdf(i, alphabet_size, n_kmers) > (-max_error_prob).ln_1p() {
	    return i;
	}
    }
    return k;
}

/// Derandomizes a single noisy _k_-bounded matching statistic.
///
/// Derandomizes the `current_ms` matching statistic (MS) based on the
/// `next_run` value obtained from the output of this function for the
/// next noisy MS when read left-to-right, the _k_-mer size `k`, and
/// the `threshold` which specifies a lower bound to consider the MS a
/// non-random match.
///
/// Positive values of the output i64 value mean that i64 characters
/// from the beginning of the k-mer match the reference, ie. same as
/// the MS, while negative values denote distance from the last
/// character in the last _k_-mer that produced a match.
///
/// # Examples
///
/// TODO Add examples to ms_to_run documentation
///
pub fn ms_to_run(
    current_ms: usize,
    next_run: i64,
    threshold: usize,
    k: usize,
) -> i64 {
    assert!(k > 0);
    assert!(threshold > 1);
    assert!(current_ms <= k);
    assert!(next_run <= k as i64);

    // Default is to decrease MS by 1.
    let mut run: i64 = next_run - 1;

    if current_ms == k {
	// Beginning of a full k-mer match
	run = k as i64;
    }

    if current_ms > threshold && next_run < current_ms as i64 {
	// Beginning of a partial k-mer match
	// Only works if threshold > 1
	run = current_ms as i64;
    }

    return run;
}

/// Derandomizes a sequence of noisy _k_-bounded matching statistics.
///
/// Iterates over a sequence of noisy _k_bounded matching statistics
/// `ms` in reverse to identify values that are the result of random
/// matching between _k_-mers of size `k` and an index that the lower
/// bound `threshold` was calculated for.
///
/// # Examples
/// TODO Add examples to derandomize_ms documentation
///
pub fn derandomize_ms(
    ms: &[usize],
    k: usize,
    threshold: usize,
) -> Vec<i64> {
    assert!(k > 0);
    assert!(threshold > 1);
    assert!(ms.len() > 2);

    let len = ms.len();

    let mut runs: Vec<i64> = vec![0; len];

    // Traverse the matching statistics in reverse.
    runs[len - 1] = ms[len - 1] as i64;
    for i in 2..len {
	runs[len - i] = ms_to_run(ms[len - i], runs[len - i + 1], threshold, k);
    }

    return runs;
}

/// Converts a derandomized _k_-bounded matching statistics vec to an alignment vec.
///
/// Iterates over a derandomized sequence of _k_bounded matching
/// statistics `runs` and creates a sequence containing a character
/// representation of the underlying alignment that generated `runs`.
///
/// The alignment is encoded using the following characters:
/// - **M** : Match between query and reference.
/// - **-** : Characters in the query that are not found in the reference.
/// - **X** : Single character mismatch or insertion into the query.
/// - **R** : Two consecutive 'R's signify a discontinuity in the alignment.
///        The right 'R' is at the start of a _k_-mer that is not adjacent
///        to the last character in the _k_-mer corresponding to the left
///        'R'. This implies either a deletion of unknown length in the query,
///        or insertion of _k_-mers from elsewhere in the reference into the query.
///
/// # Examples
/// TODO Add examples to translate_runs documentation.
///
pub fn translate_runs(
    ms: &[usize],
    runs: &[i64],
    k: usize,
    threshold: usize,
) -> Vec<char> {
    assert!(k > 0);
    assert!(threshold > 1);
    assert!(ms.len() == runs.len());
    assert!(runs.len() > 2);

    let len = runs.len();
    let mut res = vec![' '; len];

    // Traverse the runs
    for mut pos in 0..len {
	let prev: i64 = if pos > 1 { runs[pos - 1] } else { 31 };
	let curr: i64 = runs[pos];
	let next: i64 = if pos < len - 1 { runs[pos + 1] } else { runs[pos] };
	let curr_ms = ms[pos];

	let mut aln_curr = res[pos];
	let mut aln_next = if pos + 1 < len - 1 { res[pos + 1] } else { 'M' };

	if curr > threshold as i64 && next > 0 && next < threshold as i64 {
	    // Current position is first character in a jump to another k-mer,
	    // or there is deletion of unknown length in the query wrt. the reference.
	    //
	    // Use two consecutive 'R's to denote breakpoint between two k-mers
	    aln_curr = 'R';
	    aln_next = 'R';
	} else if curr <= 0 {
	    // Start of a mismatch region
	    if next == 1 && prev > 0 {
		// Mismatched character or insertion of 1 character in the query.
		//
		// Use 'X' for mismatch or 1 character insert
		aln_curr = 'X';
	    } else {
		// Insertion of more than 1 characters in the query
		//
		// Use '-' to denote inserts of more than 1 characters
		aln_curr = '-';
	    }
	} else {
	    // Other values are always a match, use 'M' for these
	    aln_curr = 'M';
	}
	res[pos] = aln_curr;
	if pos + 1 < len - 1 {
	    res[pos + 1] = aln_next;
	}
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
// Tests
//
#[cfg(test)]
mod tests {
    use assert_approx_eq::assert_approx_eq;

    #[test]
    fn log_rm_max_cdf() {
	let expected = vec![-1306319.1078024083,-318761.2492719044,-79220.9269610741,-19776.1823255263,-4942.2344281681,-1235.4454790664,-308.8543003470,-77.2131332649,-19.3032557026,-4.8258121998,-1.2064529421,-0.3016132288,-0.0754033068,-0.0188508267,-0.0047127067,-0.0011781767,-0.0002945442,-0.0000736360,-0.0000184090,-0.0000046023,-0.0000011506,-0.0000002876,-0.0000000719,-0.0000000180,-0.0000000045,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000];
	let alphabet_size = 4;
	let n_kmers = 20240921;
	let k = 1..32;
	k.for_each(|t| assert_approx_eq!(super::log_rm_max_cdf(t, alphabet_size, n_kmers), expected[t - 1], 1e-8f64));
    }

    #[test]
    fn random_match_threshold() {
	let expected = vec![15,18,22,25,28];
	let alphabet_size = 4;
	let n_kmers = 20240921;
	let k = 31;
	let factor = 1..6;
	factor.for_each(|i| assert_eq!(super::random_match_threshold(k, n_kmers, alphabet_size, (0.01_f64).powf(i as f64)), expected[i - 1]));
    }

    // TODO Test cases for ms_to_run

    // TODO Test cases for run_to_aln

    #[test]
    fn derandomize_ms() {
	let input = vec![1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,11,11,12,11,10,11,11,12,11,12,10,11,12,12,10,11,11,11,11,11,11,10,11,11,12,13,11,12,13,14,15,16,13,14,15,16,12,12,13,14,15,16,17,18,19,20,21,22,12,10,10,11,12,11,10,11,12,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,13,14,15,12,12,10,11,11,11,12,13,13,14,15,11,11,11,11,11,11,12,13,14,11,11,11,11,12,13,12,12,12,12,13,12,13,14,12,13,11,12,12,11,12,11,12,13,14,14,13,14,15,15,16,17,18,19,19,19,20,21,22,12,13,11,11,12,12,13,14,15,16,17,18,19,20,21,22,10,11,9,10,10,11,11,12,11,11,12,13,13,14,12,11,11,12,13,12,13,12,12,12,12,13,11,12,12,10,11,11,10,11,11,12,10,9,10,10,10,11,12,10,9,10,10,10,11,10,11,12,10,8,9,10,9,9,10,9,10,10,10,11,12,13,14,15,16,17,13,11,11,11,12,11,11,12,12,11,11,12,12,13,14,15,11,12,10,11,9,10,11,11,11,11,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,11,12,12,13,11,11,12,13,14,13,11,11,12,13,14,15,16,17,18,19,20,21,11,12,11,11,12,11,12,12,12,12,11,10,11,12,11,11,12,13,12,12,11,12,13,13,13,11,11,12,11,12,13,12,13,14,15,16,17,18,19,20,21,11,12,13,9,10,11,10,10,10,11,12,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27];
	let expected = vec![0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27];

	let got = super::derandomize_ms(&input, 31, 22);
	assert_eq!(got, expected);
    }

    #[test]
    fn translate_runs() {
	let expected = vec!['M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M','M'];
	let input_ms: Vec<usize> = vec![1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,11,11,12,11,10,11,11,12,11,12,10,11,12,12,10,11,11,11,11,11,11,10,11,11,12,13,11,12,13,14,15,16,13,14,15,16,12,12,13,14,15,16,17,18,19,20,21,22,12,10,10,11,12,11,10,11,12,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,13,14,15,12,12,10,11,11,11,12,13,13,14,15,11,11,11,11,11,11,12,13,14,11,11,11,11,12,13,12,12,12,12,13,12,13,14,12,13,11,12,12,11,12,11,12,13,14,14,13,14,15,15,16,17,18,19,19,19,20,21,22,12,13,11,11,12,12,13,14,15,16,17,18,19,20,21,22,10,11,9,10,10,11,11,12,11,11,12,13,13,14,12,11,11,12,13,12,13,12,12,12,12,13,11,12,12,10,11,11,10,11,11,12,10,9,10,10,10,11,12,10,9,10,10,10,11,10,11,12,10,8,9,10,9,9,10,9,10,10,10,11,12,13,14,15,16,17,13,11,11,11,12,11,11,12,12,11,11,12,12,13,14,15,11,12,10,11,9,10,11,11,11,11,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,11,12,12,13,11,11,12,13,14,13,11,11,12,13,14,15,16,17,18,19,20,21,11,12,11,11,12,11,12,12,12,12,11,10,11,12,11,11,12,13,12,12,11,12,13,13,13,11,11,12,11,12,13,12,13,14,15,16,17,18,19,20,21,11,12,13,9,10,11,10,10,10,11,12,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27];
	let input_runs: Vec<i64> = vec![1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27];
	let got = super::translate_runs(&input_ms, &input_runs, 31, 22);
	assert_eq!(got, expected);
    }
}
